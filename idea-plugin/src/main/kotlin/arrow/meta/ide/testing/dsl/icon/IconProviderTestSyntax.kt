package arrow.meta.ide.testing.dsl.icon

import arrow.meta.ide.testing.Source
import arrow.meta.ide.testing.dsl.IdeTestSyntax
import com.intellij.ide.IconProvider
import com.intellij.openapi.util.Iconable
import com.intellij.testFramework.fixtures.CodeInsightTestFixture
import javax.swing.Icon

/**
 * [IconProviderTestSyntax] provides test methods for [IconProvider].
 */
interface IconProviderTestSyntax {
  /**
   * resolves the fileIcon for the provided [code]
   * @param flag is from [com.intellij.openapi.util.Iconable]
   */
  fun IdeTestSyntax.iconProvider(code: Source, myFixture: CodeInsightTestFixture, flag: Int = Iconable.ICON_FLAG_VISIBILITY): Icon? =
    lightTest { code.toKtFile(myFixture)?.getIcon(flag) }

  // fixme: test for a specific icon as soon as the compiler plugins
  //  provide custom icons for PSI elements.
  // this kind of icon is unrelated to gutter icons

  // fixme: this is not yet working, because
  //   - the kotlin class was created on the fly and the Kotlin compiler plugin has
  //   not yet been run on this source file
  //   Possible fixes:
  //   - integrate the Kotlin compiler and the Arrow compiler plugin somehow at runtime
  //   - don't create a file on-the-fly, but store it on disk. Generate the arrow bytecode and add
  //     the generated bytecode data to the vcs.
  //     Then make use of it in the tests, i.e. load the source from disk

  // TODO: uncomment when we have the heavy tests working
  //val psiType = (psi as? KtProperty)?.type()
  //Assert.assertTrue("psi element must resolve to a valid type", psiType != null && psiType !is UnresolvedType)
}
