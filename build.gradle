import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

buildscript {
    ext.set("PATH_APIDOCS", "${rootDir}/docs/docs/apidocs")
}

plugins {
    id 'org.jetbrains.kotlin.jvm' version "$KOTLIN_VERSION" apply false
    id "org.jetbrains.dokka" version "$DOKKA_VERSION" apply false
    id "org.jlleitschuh.gradle.ktlint" version "$KTLINT_GRADLE_VERSION" apply false
}

// APIDOC
configure(subprojects - project("docs")
) {
    apply plugin: "org.jetbrains.dokka"
    dokkaGfm {
        outputDirectory = file(PATH_APIDOCS)
        dokkaSourceSets {
            if (file("src/main/kotlin").exists()) {
                main {
                    skipDeprecated.set(true)
                    reportUndocumented.set(true)
                    sourceLink {
                        localDirectory.set(file("src/main/kotlin"))
                        remoteUrl.set(uri("https://github.com/arrow-kt/arrow-meta/blob/main/${relativeProjectPath('src/main/kotlin')}").toURL())
                        remoteLineSuffix.set("#L")
                    }
                }
            } else if (file("src/commonMain/kotlin").exists()) {
                main {
                    skipDeprecated.set(true)
                    reportUndocumented.set(true)
                    sourceLink {
                        localDirectory.set(file("src/commonMain/kotlin"))
                        remoteUrl.set(uri("https://github.com/arrow-kt/arrow-meta/blob/main/${relativeProjectPath('src/commonMain/kotlin')}").toURL())
                        remoteLineSuffix.set("#L")
                    }
                }
            }
        }
    }
}

// Publication
configure(subprojects - project("docs")
) {
    group = GROUP
    version = VERSION_NAME
}

// JVM Publication
configure(subprojects -
        project(":docs") -
        project(":gradle-plugin-commons") -
        project(":analysis-types") // MPP subprojects
) {
    afterEvaluate {
        jar {
            archiveBaseName = POM_ARTIFACT_ID
            manifest {
                attributes["Specification-Title"] = project.name
                attributes["Specification-Version"] = project.version
                attributes["Implementation-Title"] = POM_NAME
                attributes["Implementation-Version"] = project.version
            }
        }
    }
    apply from: "${rootDir}/gradle/publication.gradle"
}

allprojects {
    repositories {
        mavenCentral {// try to resolve by pom firstmavenCentral {
            metadataSources {
                mavenPom()
            }
        }
        // try to get artifacts if no useful pom is found
        mavenCentral {
            metadataSources {
                artifact()
            }
        }
        // Ivy can be used as well
        ivy {
            url "https://www.sosy-lab.org/ivy"
            patternLayout {
                artifact "/[organisation]/[module]/[classifier]-[revision].[ext]"
                //ivy "/[organisation]/[module]/ivy-[revision].xml"
            }
            metadataSources {
                artifact()
            }
        }
        // SMT-Solver Princess repo
        maven {
            allowInsecureProtocol true
            url "http://logicrunch.research.it.uu.se/maven/"
        }
        maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
    }
}

task generateDoc(type: Exec) {
    // Reason of commandLine: to avoid specifying the list of modules
    commandLine "sh", "gradlew", "dokkaGfm"
}

task runValidation(type: Exec) {
    commandLine "sh", "gradlew", ":docs:runAnk"
}

task buildMetaDoc {
    group = "documentation"
    description = "Generates API Doc and validates all the documentation"
    dependsOn 'generateDoc'
    dependsOn 'runValidation'
}

runValidation.mustRunAfter generateDoc

// All KotlinCompile tasks depend on the fatJar task of the compiler plugin
project("analysis-laws").tasks.withType(KotlinCompile).configureEach {
    dependsOn project("analysis-kotlin-plugin").tasks["jar"]
}

apply from: "${rootDir}/gradle/publication.gradle"
